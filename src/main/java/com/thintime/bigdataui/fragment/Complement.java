package com.thintime.bigdataui.fragment;

/**
 * @author Thintime
 * @create 2020/4/30
 * @desc todo 补码
 */
public class Complement {
    /**
     * @note 原码 = 符号位(+0/-1) + 7bits，合理范围[-127, 127]
     *      00000001(1) + 10000001(-1) = 10000010(-2)  <p>{@remark}正负数相加出错</p>
     * @note 反码：正数 = 原码，负数 = 符号位 + 其他位取反
     *      00000001(1) + 11111110(-1) = 11111111(-0)  <p>{@remark}产生了+0和-0</p>
     * @result 补码：正数 = 原码，负数 = 反码 + 1 =  绝对值按位取反 + 1
     *      11111111(-0) + 1 = 1 00000000 -> 00000000(+0)  <p>{@remark}-0的最高位丢失，变成+0</p>
     * @result -0不存在，10000000用来表示-128(没有原码)，实际范围[-128, 127]
     */
    public static void main(String[] args) {
        /**
         * @source 00000000000000000000000000000 110        +6
         * @parse  11111111111111111111111111111 010        -6
         *       & 11111111111111111111111111111 110        -2
         * @result 11111111111111111111111111111 010        -6
         */
        System.out.println(-6&-2);
        System.out.println(-6^-2); //按位异或操作，异1

        /**
         * @note float = 1位符号位(s)-8位指数位(E)-23位有效数字(M) = (-1)^s * (1+M) * 2^(E-127)
         *      -2499.0= -1001 1100 0011.0=-1.001110000110 * 2^11
         * @result M=00111000011000000000000，E=138=10001010
         *         -2499.0=1[10001010][00111000011000000000000]=c5 1c 30 00
         * @fact 实际的内存可能是00 30 1c c5，是因为小端法
         *       @note 低位字节(原地址右边)放在低地址，高位放在高地址
         */
    }
}
